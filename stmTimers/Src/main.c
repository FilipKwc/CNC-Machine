/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */


#include "clkdir.h"
#include "timer.h"
#include "fifo.h"
#include "motor.h"
#include "main.h"

#define BMP_SIZE 100
#define NEWLINE '\n'



//volatile uint8_t bitmap[BMP_SIZE];
//volatile uint32_t bmp_index = 0;
//volatile uint8_t bmp_ready = 0;
volatile uint8_t data;
volatile bool bitmap_ready=false;
volatile bool fifo_busy=false;

uint16_t pixel;
fifo_t pixel_fifo = {0};
StepMotorAxis axis_X;
StepMotorAxis axis_Y;
StepMotorAxis axis_Z;
MachineState_StepMotor drill=DOWN_FIFO;



void USART2_EXTI26_IRQHandler (void)
{

	if(USART2->ISR & USART_ISR_RXNE)
	{
	     	data = USART2->RDR;
	     	fifo_push(&pixel_fifo, data);
	     	if(pixel_fifo.head==2550)
	     	{

	     				bitmap_ready=true;

	     	}
		USART2->RQR |= USART_RQR_RXFRQ;
		if (USART2->ISR & USART_ISR_ORE)
		{
		    USART2->ICR |= USART_ICR_ORECF;
		}
		if (USART2->ISR & USART_ISR_FE)
		{
			USART2->ICR |= USART_ICR_FECF;
		}
		if (USART2->ISR & USART_ISR_NE)
				{
					USART2->ICR |= USART_ICR_NCF;
				}
	}

}

uint32_t counter;
uint8_t Flag_pixel;
uint8_t END_Machine;
volatile bool confirm_returnDRILL_x_toFIFO=false;
volatile bool confirmDRILL_z=false;
volatile bool returnDRILL_z=false;
volatile bool confirm_returnDRILL_z=true;
volatile bool confirm_returnDRILL_x=false;
 bool confirmDRILL_y=false;
volatile bool confirmDRILL_x=false;
volatile bool moveto_x=false;
volatile bool moveto_z=true;
bool raw_Rdir=true;
bool raw_Ldir=false;
volatile uint8_t z_state = 0;
volatile bool ISRz=false;
volatile bool ISRx=false;
volatile bool ISRy=false;
const uint16_t move_x = 500;
volatile uint32_t moveback_x=0;
const uint16_t move_y = 400;
const uint16_t backtostep_x = 10000;
volatile int cntx, cnty, cntz;
volatile int cntz=0;
volatile int cntx=0;
void CNC_Machine(void);
uint32_t GetSystemTick(void);
void SysTick_Handler(void);
uint32_t count_fifo=0;
volatile uint32_t Tick=0;
uint32_t last_fifo_tick = 0;

int main(void)
{


	clock_config();
	SysTick_Config(72000000/100000);
	config_UART();
	DIRconfig_x();
	DIRconfig_y();
	DIRconfig_z();
	 CHIPEconfig_x();
	 CHIPEconfig_y();
	 CHIPEconfig_z();
	configure_y_TIMER15();
	configure_x_TIMER2();
	configure_z_TIMER17();
	ChipEnable(ChipE_x, 1, GPIOA);
	ChipEnable(ChipE_y, 1, GPIOA);
	ChipEnable(ChipE_z,1,GPIOC);


	stepmotor_axis(&axis_X, GPIOB, GPIOA, 3,TIM2,0);
	stepmotor_axis(&axis_Y, GPIOB, GPIOB, 4,TIM15,10);
	stepmotor_axis(&axis_Z, GPIOB, GPIOA, 5,TIM17,7);



	while(1)

	{


		if(bitmap_ready == true)
				{
				CNC_Machine();
				}



	}
}




volatile bool flaga_z;

volatile bool z_done;
volatile bool z_busy = false;

void TIM1_BRK_TIM15_IRQHandler(void)
{
		//Y
if(ISRy==true)
{


	stepmotor_stop(&axis_Z);
	stepmotor_stop(&axis_X);
	ISRz=true;
	ISRx=false;

	    if (TIM15->SR & TIM_SR_CC1IF)
	    {

	        	  TIM15->SR &= ~TIM_SR_CC1IF; // Wyczyść flagę

	        	  if(axis_Y.steps_move>cnty)
	        	  {
	        		  cnty++;
	        		  GPIOB->ODR ^= GPIO_ODR_10;  // pb10


  	        		  if(axis_Y.steps_move==cnty)
  	        		  {
  	        			   cnty=0;
  	        			   axis_Y.steps_move=0;
  	        			  ISRx=true;
  	        			  ISRz=true;
   	        		  	 confirmDRILL_z=true;
  	        		  	 confirmDRILL_y=false;
  	        		  	 confirm_returnDRILL_x=true;
  	        		  	 moveto_x=true;
  	        			  ISRy=false;
  	        			 stepmotor_stop(&axis_Y);
  	        		  }
	        	  }
	        }

		if (TIM15->SR & TIM_SR_UIF)
	       {

	    		TIM15->SR &= ~TIM_SR_UIF;
	       }
}
}
void TIM2_IRQHandler(void)
{
	if(ISRx==true)
	{

	    if (TIM15->SR & TIM_SR_CC1IF)
	    {

	        	  TIM15->SR &= ~TIM_SR_CC1IF;
	    }
	    if (TIM15->SR & TIM_SR_UIF)
	    	       {

	    	    		TIM15->SR &= ~TIM_SR_UIF;
	    	       }
		stepmotor_stop(&axis_Z);
		stepmotor_stop(&axis_Y);
		ISRy=false;
		ISRz=true;
	    if (TIM2->SR & TIM_SR_CC1IF)
	    {
	        TIM2->SR &= ~TIM_SR_CC1IF;
	        if(axis_X.steps_move>cntx)
	      	        	  {

	      	        		  GPIOA->ODR ^= GPIO_ODR_0;
      						cntx++;

      						moveback_x++;
      						if(confirm_returnDRILL_x==true)
      						{
      							moveback_x=0;
      						}
	      	        		  if(axis_X.steps_move==cntx)
	      	        		  {

	      	        			  cntx=0;
	                  			axis_X.steps_move=0;
	                			confirmDRILL_z=false;
	                			confirmDRILL_x=false;
	                			fifo_busy=false;
	                			ISRz = false;
	                			ISRx = false;
	                			stepmotor_stop(&axis_X);

	      	        		  }
	      	        		 if(axis_X.steps_move==cntx && confirm_returnDRILL_x == true)
	      	        			      	        		  {
	      	        			      	        			  cntx=0;
	      	        			                  			axis_X.steps_move=0;
	      	        			                  			moveback_x=0;
	      	        			                			confirmDRILL_x=false;
	      	        			                			moveto_x=false;
	      	        			                			confirm_returnDRILL_x=false;
	      	        			                			confirm_returnDRILL_x_toFIFO=true;
	      	        			                			ISRz = false;
	      	        			                			ISRy=false;
	      	        			                			ISRx = false;
	      	        			                			fifo_busy = false;
	      	        			                			stepmotor_stop(&axis_X);
	      	        			      	        		  }
	      	        	  }

	    }
	    if (TIM2->SR & TIM_SR_UIF)
	    	       {
	    	           TIM2->SR &= ~TIM_SR_UIF;

	    	       }
	}
	}



void TIM1_TRG_COM_TIM17_IRQHandler(void)
{
if (ISRz == false)
{
	stepmotor_stop(&axis_X);
	ISRx=false;
    if (TIM17->SR & TIM_SR_CC1IF)
    {
        TIM17->SR &= ~TIM_SR_CC1IF;
        if (axis_Z.steps_move > cntz)
        {
        	GPIOA->ODR ^= GPIO_ODR_7;
            cntz++;
            if (axis_Z.steps_move == cntz && dir_z == true)
                       {
            			cntz=0;
            			axis_Z.steps_move=0;
            			confirmDRILL_z=true;
            			stepmotor_stop(&axis_Z);
                       }
            if (axis_Z.steps_move == cntz && dir_z == false)
            {
              	cntz=0;
            	axis_Z.steps_move=0;
				ISRz=true;
				ISRx=true;
				confirmDRILL_x=true;
            	stepmotor_stop(&axis_Z);
            }
        }
    }
    if (TIM17->SR & TIM_SR_UIF)
    {
        TIM17->SR &= ~TIM_SR_UIF;
    }
	}
}



void TIM8_UP_IRQHandler (void)
{
	 if (TIM8->SR & TIM_SR_CC1IF)
		    {


			if(bitmap_ready == true)
			{
			CNC_Machine();
			}

		    }



	   if (TIM8->SR & TIM_SR_UIF)
		    	       {
		    	           TIM8->SR &= ~TIM_SR_UIF;

		    	       }
}


void CNC_Machine(void)
{
	switch(drill)
	{
	case DOWN_FIFO:

if(fifo_busy == false )
{
		if(	fifo_pop(&pixel_fifo,&pixel))
			     			{

			     				fifo_busy=true;

			     			}

 	if(pixel==NEWLINE)
 {
 		confirmDRILL_z=true;
 		axis_Z.steps_move=0;
 			ISRy = true;
 			confirmDRILL_y=true;
 			drill = MOVEBACK_Y;
 }
} else
{
	drill=DRILL_Z;
}

		break;
	case DRILL_Z:
		if(false==confirmDRILL_z)
				{

				        stepmotor_move_z(&axis_Z, pixel, 1); // dół
				}


		drill=BACKDRILL_Z;
		break;

	case BACKDRILL_Z:
		if(confirmDRILL_z==true)
		{

			  stepmotor_move_z(&axis_Z, pixel, 0); // góra


		}

		drill=STEP_X;

			break;
	case STEP_X:

		if(confirmDRILL_x==true)
		{
			stepmotor_run(&axis_X, 700,0);
		}

		drill=DOWN_FIFO;
		break;

	case MOVEBACK_Y:

		if(confirmDRILL_y == true)
		{
			stepmotor_stop(&axis_Z);

	        stepmotor_run(&axis_Y, 700, 0);
		}
if(moveto_x==true)
{
		drill = MOVE_BACK_X;
}
		break;
	case MOVE_BACK_X:


		stepmotor_run(&axis_X, moveback_x, 1);


		drill = DOWN_FIFO;
	break;
	}
}



uint32_t GetSystemTick()
{
	return Tick;
}
void SysTick_Handler(void)
{
	Tick++;
}





